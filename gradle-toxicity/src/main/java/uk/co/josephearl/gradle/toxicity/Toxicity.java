/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.josephearl.gradle.toxicity;

import groovy.lang.Closure;
import org.gradle.api.Action;
import org.gradle.api.InvalidUserDataException;
import org.gradle.api.file.FileCollection;
import org.gradle.api.internal.project.IsolatedAntBuilder;
import org.gradle.api.reporting.Reporting;
import org.gradle.api.resources.TextResource;
import org.gradle.api.tasks.*;
import org.gradle.internal.reflect.Instantiator;

import java.io.File;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.inject.Inject;

/**
 * Runs Toxicity against some source files.
 */
public class Toxicity extends SourceTask implements Reporting<ToxicityReports> {
  private FileCollection checkstyleClasspath;
  private FileCollection toxicityClasspath;
  private FileCollection classpath;
  private TextResource config;
  private TextResource checkstyleXmlReport;
  private Map<String, Object> configProperties = new LinkedHashMap<String, Object>();
  private final ToxicityReports reports;

  public Toxicity() {
    reports = getInstantiator().newInstance(ToxicityReportsImpl.class, this);
  }

  public File getConfigFile() {
    return getConfig() == null ? null : getConfig().asFile();
  }

  public void setConfigFile(File configFile) {
    setConfig(getProject().getResources().getText().fromFile(configFile));
  }

  @Inject
  public Instantiator getInstantiator() {
    throw new UnsupportedOperationException();
  }

  @Inject
  public IsolatedAntBuilder getAntBuilder() {
    throw new UnsupportedOperationException();
  }

  @Deprecated
  @Override
  public ToxicityReports reports(Closure closure) {
    return reports(new ClosureBackedAction<ToxicityReports>(closure));
  }

  public ToxicityReports reports(Action<? super ToxicityReports> configureAction) {
    configureAction.execute(reports);
    return reports;
  }

  @TaskAction
  public void run() {
    if (reports.getEnabled().isEmpty()) {
      throw new InvalidUserDataException("Toxicity tasks must have one report enabled, however neither the csv or html report is enabled for task '$path'");
    }
    if (reports.getEnabled().size() > 1) {
      throw new InvalidUserDataException("Toxicity tasks can only have one report enabled, however both the csv and html report is enabled for task '$path'");
    }
    CheckstyleInvoker.invoke(this);
    ToxicityInvoker.invoke(this);
  }

  /**
   * The class path containing the Checkstyle library to be used.
   */
  @InputFiles
  public FileCollection getCheckstyleClasspath() {
    return checkstyleClasspath;
  }

  public void setCheckstyleClasspath(FileCollection checkstyleClasspath) {
    this.checkstyleClasspath = checkstyleClasspath;
  }

  @InputFiles
  public FileCollection getToxicityClasspath() {
    return toxicityClasspath;
  }

  public void setToxicityClasspath(FileCollection toxicityClasspath) {
    this.toxicityClasspath = toxicityClasspath;
  }

  @InputFiles
  public FileCollection getClasspath() {
    return classpath;
  }

  public void setClasspath(FileCollection classpath) {
    this.classpath = classpath;
  }

  @Nested
  public TextResource getConfig() {
    return config;
  }

  public void setConfig(TextResource config) {
    this.config = config;
  }

  TextResource getCheckstyleXmlReport() {
    return checkstyleXmlReport;
  }

  void setCheckstyleXmlReport(TextResource checkstyleXmlReport) {
    this.checkstyleXmlReport = checkstyleXmlReport;
  }

  File getCheckstyleXmlReportFile() {
    return checkstyleXmlReport.asFile();
  }

  void setCheckstyleXmlReportFile(File checkstyleXmlReport) {
    this.checkstyleXmlReport = getProject().getResources().getText().fromFile(checkstyleXmlReport);
  }

  /**
   * The properties available for use in the configuration file. These are substituted into the configuration file.
   */
  @Input
  @Optional
  public Map<String, Object> getConfigProperties() {
    return configProperties;
  }

  public void setConfigProperties(Map<String, Object> configProperties) {
    this.configProperties = configProperties;
  }

  /**
   * The reports to be generated by this task.
   */
  @Nested
  @Override
  public final ToxicityReports getReports() {
    return reports;
  }
}